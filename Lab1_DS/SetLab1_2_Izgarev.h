#pragma once
#include <string>

struct Node {
	int value;
	Node* next;
};

/*
	F1. Создание пустого множества. 
	Входные параметры: нет. 
	Выходные параметры: указатель на первый элемент списка, равный NULL.
*/
Node* CreateSetList();

/*
	F2. Пустое множество? 
	Входные параметры: указатель на первый элемент списка. 
	Выходные параметры: логическое значение.
*/
bool EmptySetList(Node* first_element);

/*
	F3. Проверка принадлежности элемента множеству. 
	Входные параметры: указатель на первый элемент списка, значение элемента. 
	Выходные параметры: логическое значение. Использовать F2.
*/
bool ItemInSetList(Node* first_element, int val);

/*
	F4. Добавление нового элемента в множество. 
	Входные параметры: указатель на первый элемент списка, добавляемое в список значение. 
	Выходные параметры: указатель на первый элемент списка-результата. 
	Использовать F3. Ограничение: добавление осуществлять в начало списка.
*/
Node* AddItem(Node* first_element, int val);

/*
	F5. Создание множества. 
	Входные параметры: количество элементов, интервал допустимых значений (от min до max). 
	Выходные параметры: указатель на первый элемент списка-результата. 
	Генерация значений – датчиком случайных чисел. 
	Использовать F4. 
	Требования: проверить возможность создания множества с заданными параметрами.
*/
Node* CreateSetList(int len, int min, int max, char sym);

// функция улучшаящая функцию F5
int GenerateValueAorB(int min, int max, char sym);
/// дополнительная функция для генерации случайных чисел
int random(int low, int high);

/*
	F6. Мощность множества. 
	Входные параметры: указатель на первый элемент списка. 
	Выходные параметры: целочисленное значение. 
	Использовать F2.
*/
int PowerSetList(Node* first_element);

/*
	F7. Вывод элементов множества. 
	Входные параметры: указатель на первый элемент списка, символ разделителя. 
	Выходные параметры: строка, содержащая элементы множества, разделенные символом разделителя. 
	Использовать F2. 
	Требования: в конце строки-результата разделитель стоять не должен
*/
std::string ToString(Node* first_element, char sym);

/*
	F8. Удаление множества (очистка памяти, занимаемой списком). 
	Входные параметры: указатель на первый элемент списка. 
	Выходные параметры: указатель на первый элемент списка, равный NULL.
*/
Node* DeleteSetList(Node* first_element);

/*
	F9. Подмножество А-В. Входные параметры: два указателя на первые элементы списков – исходных множеств А и В. 
	Выходные параметры: логическое значение True, если А является подмножеством В. 
	Использовать F2, F6.
*/
bool CheckSubSet(Node* sub_set, Node* set);

/*
	F10. Равенство двух множеств А-В. 
	Входные параметры: два указателя на первые элементы списков – исходных множеств А и В. 
	Выходные параметры: логическое значение True, если А равно В. Использовать F9.
*/
bool EqualsSets(Node* first_set, Node* second_set);

/*
	F11. Объединение двух множеств. 
	Входные параметры: два указателя на первые элементы списков – исходных множеств. 
	Выходные параметры: указатель на первый элемент списка-результата. Использовать F2, F4.
*/
Node* MergeSets(Node* first_set, Node* second_set);

/*
	F12. Пересечение двух множеств. 
	Входные параметры: два указателя на первые элементы списков – исходных множеств. 
	Выходные параметры: указатель на первый элемент списка-результата. Использовать F2, F4.
*/
Node* IntersectionSets(Node* first_set, Node* second_set);

/*
	F13. Разность множеств. 
	Входные параметры: два указателя на первые элементы списков – исходных множеств. 
	Выходные параметры: указатель на первый элемент списка-результата. Использовать F2, F4.
*/
Node* DifferenceSets(Node* first_set, Node* second_set);

/*
	F14. Симметричная разность. 
	Входные параметры: два указателя на первые элементы списков – исходных множеств. 
	Выходные параметры: указатель на первый элемент списка-результата. Использовать F11, F12 и F13.
*/
Node* SymmetricDifferenceSets(Node* first_set, Node* second_set);